import json
import os
import random
import time
import shutil
import pandas as pd
import lancedb

from langchain_community.chat_models import ChatOpenAI
from langchain.embeddings.openai import OpenAIEmbeddings
from langchain_core.messages import HumanMessage
from langchain_community.vectorstores import LanceDB

# Load utilities and constants
from llm_pipeline.utils import (
    parse_price,
    fallback_string,
    fallback_int,
    get_fallback_description,
    CITIES,
)
from llm_pipeline.logger import setup_logger


class RealEstateIndexer:
    """    A class to generate and index real estate listings using LLMs and LanceDB.
    This class handles the generation of property listings, sanitization, embedding,
    and indexing into a LanceDB vector store for efficient querying.
    """

    def __init__(self, db_path: str = "./db", table_name: str = "listings", output_csv: str = "./outputs/listings.csv") -> None:
        """
        Initializes the RealEstateIndexer with the specified database path, table name, and output CSV file.
        This method sets up the LanceDB connection, initializes the LLM and embedding model,
        and prepares the output directory for storing generated listings.
        :param db_path: Path to the LanceDB database directory.
        :param table_name: Name of the table in the LanceDB database.
        :param output_csv: Path to the CSV file where generated listings will be saved.
        """
        self.logger = setup_logger()
        self.db_path = db_path
        self.table_name = table_name
        self.table_uri = os.path.join(db_path, table_name)
        self.output_csv = output_csv

        self.llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.7, openai_api_key=os.getenv("OPENAI_API_KEY"))
        self.embedding_model = OpenAIEmbeddings()

        os.makedirs(os.path.dirname(self.output_csv), exist_ok=True)
        if os.path.exists(self.table_uri):
            shutil.rmtree(self.table_uri)

        os.makedirs(db_path, exist_ok=True)
        self.db = lancedb.connect(db_path)

    def return_vectorstore(self) -> LanceDB or None:
        """
        Returns the LanceDB vector store for real estate listings.
        This allows for similarity searches and efficient querying of listings.
        :return: LanceDB vector store instance
        """
        try:
            return LanceDB(
                connection=self.db,
                table_name=self.table_name,
                embedding=self.embedding_model,
            )
        except Exception as e:
            self.logger.error(f"❌ Failed to create vector store: {e}")
            return None

    def generate_listing_json(self, minimal_input: str = None) -> dict or None:
        """
        Generates a real estate listing in JSON format using an LLM.
        :param minimal_input: Optional string to customize the listing generation.
        :return:
        """
        prompt = f"""
       You are a real estate listing assistant. Generate a full property listing in JSON format with:
       - title
       - description
       - price
       - location (choose from: {', '.join(CITIES)})
       - number_of_bedrooms
       - number_of_bathrooms
       - square_feet
       - amenities
       - neighborhood
       - neighborhood_description
       {"Use this input to customize the listing: " + minimal_input if minimal_input else "Generate a varied and plausible listing."}
       Return only valid JSON.
       """
        try:
            response = self.llm([HumanMessage(content=prompt)])
            return json.loads(response.content)
        except Exception as e:
            self.logger.error(f"❌ LLM generation failed: {e}")
            return None

    @staticmethod
    def sanitize(listing: dict) -> dict:
        """ Sanitizes the generated listing JSON to ensure all fields are valid and properly formatted.
        :param listing: The raw listing dictionary generated by the LLM.
        :return: A sanitized dictionary with all fields properly formatted.
        """

        # Ensure all fields are present and properly formatted
        description = str(listing.get("description")) if listing.get(
            "description") else "A beautiful and comfortable property in a prime location."

        # Use fallback_string to pick from your list if invalid or missing
        location = fallback_string(listing.get("location"), CITIES)
        # neighborhood = fallback_string(listing.get("neighborhood"), NEIGHBORHOODS)

        return {
            "title": str(listing.get("title")),
            "description": description,
            "price": parse_price(listing.get("price")),
            "location": location,
            "number_of_bedrooms": fallback_int(listing.get("number_of_bedrooms")),
            "number_of_bathrooms": fallback_int(listing.get("number_of_bathrooms")),
            "square_feet": fallback_int(listing.get("square_feet"), default=random.randint(400, 8000)),
            "amenities": [str(a) for a in listing.get("amenities")],
            "neighborhood": listing.get("neighborhood"),
            "neighborhood_description": str(
                listing.get("neighborhood_description") or get_fallback_description(listing.get("neighborhood"))
            ),
            "vector": list(map(float, listing.get("embedding", [0.0] * 1536))),
        }

    def run_generation_loop(self, count: int = 100, minimal_input: str = None) -> list:
        """
        Generates a specified number of real estate listings, embedding them, and sanitizing the output.
        This method handles the generation of listings, embedding their descriptions,
        and storing them in a list for further processing.
        :param count: The number of listings to generate.
        :param minimal_input: Optional input to customize the listing generation.
        :return: list of sanitized listings
        """
        listings = []
        for i in range(count):
            listing = self.generate_listing_json(minimal_input=minimal_input)
            if listing:
                try:
                    listing["embedding"] = self.embedding_model.embed_query(listing["description"])
                    time.sleep(0.5)
                    listings.append(self.sanitize(listing))
                except Exception as e:
                    self.logger.warning(f"⚠️ Embedding failed for listing {i}: {e}")

        self.logger.info(f"✅ Generated {len(listings)} listings.")
        return listings

    def index_and_save(self, listings: list, create_table: bool = False) -> None:
        """
        Indexes the generated listings into LanceDB and saves them to a CSV file.
        This method handles the conversion of listings to a DataFrame, saving them to a CSV file,
        and indexing them into LanceDB for efficient querying.
        It also handles the creation of the LanceDB table if it does not exist.
        :param listings: list of sanitized listings to index and save
        :param create_table: bool indicating whether to create a new LanceDB table
        :return: None
        """

        df = pd.DataFrame(listings)
        if not os.path.exists(self.output_csv):
            df.to_csv(self.output_csv, index=False)
        else:
            df.to_csv(self.output_csv, mode='a', header=False, index=False)

        self.logger.info(f"✅ Saved to {self.output_csv}")

        indexed_data = []
        for listing in listings:
            indexed_data.append({
                "vector": listing["vector"],
                "text": listing["description"],  # Required for LanceDB similarity search
                "metadata": {k: v for k, v in listing.items() if k not in ["vector", "description"]}
            })

        # Create and add to LanceDB
        if create_table or self.table_name not in self.db.table_names():
            table = self.db.create_table(self.table_name, data=indexed_data[:1])
            self.logger.info("✅ Created new table")
            if len(indexed_data) > 1:
                table.add(indexed_data[1:], mode='append')
        else:
            # Open existing table
            table = self.db.open_table(self.table_name)
            self.logger.info("✅ Opened existing table")
            table.add(indexed_data, mode='append')  # ✅ Add all rows

        self.logger.info(f"✅ Indexed {len(indexed_data)} listings to LanceDB.")
        self.logger.info(f"📋 Schema: {table.schema}")
